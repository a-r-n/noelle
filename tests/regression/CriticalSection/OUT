clang++ -I../../include/threadpool/include -emit-llvm -O0 -Xclang -disable-O0-optnone -std=c++14 -c test.cpp -o test.bc
clang++ -O3 -c -emit-llvm test.bc -o baseline.bc
llvm-dis baseline.bc
clang++ -O3 baseline.bc -o baseline
clang++ "-DDEBUG" -I../../include/threadpool/include -std=c++14 -emit-llvm -O3 -c Parallelizer_utils.cpp -o Parallelizer_utils.bc
llvm-link test.bc Parallelizer_utils.bc -o baseline_with_runtime.bc
llvm-dis baseline_with_runtime.bc
noelle-prof-coverage baseline_with_runtime.bc baseline_with_runtime_prof -lm -lstdc++ -lpthread
./baseline_with_runtime_prof `cat input.txt` 
Running 20 iterations
Result = 1729447412
mv default.profraw pre_profiles.profraw
noelle-meta-prof-embed pre_profiles.profraw baseline_with_runtime.bc -o baseline_pre.bc
opt -pgo-test-profile-file=/tmp/tmp.Cb5iM8Yzdw -block-freq -pgo-instr-use baseline_with_runtime.bc -o baseline_pre.bc
noelle-pre baseline_pre.bc -noelle-pdg-verbose=1 -noelle-verbose=2 -noelle-min-hot=0
opt --strip-debug --strip-debug-declare baseline_pre.bc -o baseline_pre.bc
noelle-deadcode baseline_pre.bc baseline_pre.bc
NOELLE: DeadFunctions: Start
NOELLE: DeadFunctions:   Input: baseline_pre.bc
NOELLE: DeadFunctions:   Output: baseline_pre.bc
NOELLE: DeadFunctions:   Temporary input: /tmp/tmp.xY7MT14ICT (.ll version is /tmp/tmp.XhO1QtPRaS)
NOELLE: DeadFunctions:   Temporary output: /tmp/tmp.uuj9S970qV (.ll version is /tmp/tmp.mg64MzEAat)
noelle-norm /tmp/tmp.xY7MT14ICT -o /tmp/tmp.uuj9S970qV
opt -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libCudd.so -basicaa -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars /tmp/tmp.xY7MT14ICT -o /tmp/tmp.uuj9S970qV
NOELLE: DeadFunctions:   Delete dead functions
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DeadFunction.so -noelle-dfe /tmp/tmp.xY7MT14ICT -o /tmp/tmp.uuj9S970qV
opt -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Loops.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Noelle.so -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DeadFunction.so -noelle-dfe /tmp/tmp.xY7MT14ICT -o /tmp/tmp.uuj9S970qV
DeadFunctionEliminator:  Considering ctor _GLOBAL__sub_I_Parallelizer_utils.cpp as entry function
noelle-simplification baseline_pre.bc -o baseline_pre.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libCudd.so -basicaa -mem2reg -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa baseline_pre.bc -o baseline_pre.bc
noelle-inline "-noelle-inliner-verbose=1 -noelle-pdg-verbose=1 -noelle-verbose=2 -noelle-min-hot=0" baseline_pre.bc
Running Inliner to inline calls within SCCs, iteration: 1
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-pdg-verbose=1 -noelle-verbose=2 -noelle-min-hot=0 /tmp/tmp.5MYfb2VLYM -o /tmp/tmp.5MYfb2VLYM
opt -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Loops.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Noelle.so -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-pdg-verbose=1 -noelle-verbose=2 -noelle-min-hot=0 /tmp/tmp.5MYfb2VLYM -o /tmp/tmp.5MYfb2VLYM
Inliner: Start
Inliner:   Profiles are available and will be used
Inliner:   No remaining call inlining in SCCs
opt -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libCudd.so -basicaa -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars /tmp/tmp.5MYfb2VLYM -o /tmp/tmp.5MYfb2VLYM
Running Inliner to hoist loops to main, iteration: 1
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-pdg-verbose=1 -noelle-verbose=2 -noelle-min-hot=0 /tmp/tmp.5MYfb2VLYM -o /tmp/tmp.5MYfb2VLYM
opt -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Loops.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Noelle.so -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Inliner.so -inliner -noelle-inliner-verbose=1 -noelle-pdg-verbose=1 -noelle-verbose=2 -noelle-min-hot=0 /tmp/tmp.5MYfb2VLYM -o /tmp/tmp.5MYfb2VLYM
Inliner: Start
Inliner:   Profiles are available and will be used
Inliner:   No remaining call inlining in SCCs
Inliner:   No remaining hoists
opt -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libCudd.so -basicaa -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars /tmp/tmp.5MYfb2VLYM -o /tmp/tmp.5MYfb2VLYM
noelle-simplification baseline_pre.bc -o baseline_pre.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libCudd.so -basicaa -mem2reg -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa baseline_pre.bc -o baseline_pre.bc
noelle-deadcode baseline_pre.bc baseline_pre.bc
NOELLE: DeadFunctions: Start
NOELLE: DeadFunctions:   Input: baseline_pre.bc
NOELLE: DeadFunctions:   Output: baseline_pre.bc
NOELLE: DeadFunctions:   Temporary input: /tmp/tmp.oJO36md3HV (.ll version is /tmp/tmp.RpC0bqWb4w)
NOELLE: DeadFunctions:   Temporary output: /tmp/tmp.n8N9FPw533 (.ll version is /tmp/tmp.mPod3ikB27)
noelle-norm /tmp/tmp.oJO36md3HV -o /tmp/tmp.n8N9FPw533
opt -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libCudd.so -basicaa -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars /tmp/tmp.oJO36md3HV -o /tmp/tmp.n8N9FPw533
NOELLE: DeadFunctions:   Delete dead functions
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DeadFunction.so -noelle-dfe /tmp/tmp.oJO36md3HV -o /tmp/tmp.n8N9FPw533
opt -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Loops.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Noelle.so -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DeadFunction.so -noelle-dfe /tmp/tmp.oJO36md3HV -o /tmp/tmp.n8N9FPw533
DeadFunctionEliminator:  Considering ctor _GLOBAL__sub_I_Parallelizer_utils.cpp as entry function
noelle-simplification baseline_pre.bc -o baseline_pre.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libCudd.so -basicaa -mem2reg -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa baseline_pre.bc -o baseline_pre.bc
noelle-enable baseline_pre.bc baseline_pre.bc -noelle-pdg-verbose=1 -noelle-verbose=2 -noelle-min-hot=0
NOELLE: Enablers: Start
NOELLE: Enablers:   Input: baseline_pre.bc
NOELLE: Enablers:   Output: baseline_pre.bc
NOELLE: Enablers:   Temporary input: /tmp/tmp.gGCrk64ZdJ (.ll version is /tmp/tmp.t43mwffBV2)
NOELLE: Enablers:   Temporary output: /tmp/tmp.k2ny3UYWif (.ll version is /tmp/tmp.FHaUNGjekA)
NOELLE: Enablers:   Start invoking enablers
NOELLE: Enablers:     Invocation 0
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Enablers.so -enablers /tmp/tmp.gGCrk64ZdJ -o /tmp/tmp.k2ny3UYWif -noelle-pdg-verbose=1 -noelle-verbose=2 -noelle-min-hot=0
opt -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Loops.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Noelle.so -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Enablers.so -enablers /tmp/tmp.gGCrk64ZdJ -o /tmp/tmp.k2ny3UYWif -noelle-pdg-verbose=1 -noelle-verbose=2 -noelle-min-hot=0
EnablersManager: Start
Parallelizer: Filter out cold code
EnablersManager:  Try to improve all 1 loops, one at a time
EnablersManager:   Try to apply loop distribution
EnablersManager:   Try to devirtualize indirect calls
EnablersManager:   Try to whilify loops
LoopWhilifier: Starting ... 
THE SCHEDULER
LoopScheduler: Starting dump ...
LoopScheduler: Blocks

19:                                               ; preds = %22, %9
  %20 = phi i32 [ %69, %22 ], [ 0, %9 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %22 ], [ 0, %9 ]
  %21 = icmp slt i64 %indvars.iv, %12
  br i1 %21, label %22, label %70, !prof !31


22:                                               ; preds = %19
  %23 = tail call double @sqrt(double %18) #30
  %24 = fadd double %23, %18
  %25 = tail call double @sqrt(double %24) #30
  %26 = fadd double %24, %25
  %27 = tail call double @sqrt(double %26) #30
  %28 = fadd double %26, %27
  %29 = tail call double @sqrt(double %28) #30
  %30 = fadd double %28, %29
  %31 = tail call double @sqrt(double %30) #30
  %32 = fadd double %30, %31
  %33 = tail call double @sqrt(double %32) #30
  %34 = fadd double %32, %33
  %35 = tail call double @sqrt(double %34) #30
  %36 = fadd double %34, %35
  %37 = tail call double @sqrt(double %36) #30
  %38 = fadd double %36, %37
  %39 = tail call double @sqrt(double %38) #30
  %40 = fadd double %38, %39
  %41 = tail call double @sqrt(double %40) #30
  %42 = fadd double %40, %41
  %43 = tail call double @sqrt(double %42) #30
  %44 = fadd double %42, %43
  %45 = tail call double @sqrt(double %44) #30
  %46 = fadd double %44, %45
  %47 = tail call double @sqrt(double %46) #30
  %48 = fadd double %46, %47
  %49 = tail call double @sqrt(double %48) #30
  %50 = fsub double %48, %49
  %51 = tail call double @sqrt(double %50) #30
  %52 = fsub double %50, %51
  %53 = tail call double @sqrt(double %52) #30
  %54 = fsub double %52, %53
  %55 = tail call double @sqrt(double %54) #30
  %56 = fsub double %54, %55
  %57 = tail call double @sqrt(double %56) #30
  %58 = fsub double %56, %57
  %59 = tail call double @sqrt(double %58) #30
  %60 = fsub double %58, %59
  %61 = tail call double @sqrt(double %60) #30
  %62 = fsub double %60, %61
  %63 = tail call double @sqrt(double %62) #30
  %64 = fsub double %62, %63
  %65 = tail call double @sqrt(double %64) #30
  %66 = fsub double %64, %65
  %67 = fptosi double %66 to i32
  %68 = load i32, i32* %16, align 4
  %69 = add nsw i32 %68, %67
  store i32 %69, i32* %16, align 4
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %19

LoopScheduler: Latch

22:                                               ; preds = %19
  %23 = tail call double @sqrt(double %18) #30
  %24 = fadd double %23, %18
  %25 = tail call double @sqrt(double %24) #30
  %26 = fadd double %24, %25
  %27 = tail call double @sqrt(double %26) #30
  %28 = fadd double %26, %27
  %29 = tail call double @sqrt(double %28) #30
  %30 = fadd double %28, %29
  %31 = tail call double @sqrt(double %30) #30
  %32 = fadd double %30, %31
  %33 = tail call double @sqrt(double %32) #30
  %34 = fadd double %32, %33
  %35 = tail call double @sqrt(double %34) #30
  %36 = fadd double %34, %35
  %37 = tail call double @sqrt(double %36) #30
  %38 = fadd double %36, %37
  %39 = tail call double @sqrt(double %38) #30
  %40 = fadd double %38, %39
  %41 = tail call double @sqrt(double %40) #30
  %42 = fadd double %40, %41
  %43 = tail call double @sqrt(double %42) #30
  %44 = fadd double %42, %43
  %45 = tail call double @sqrt(double %44) #30
  %46 = fadd double %44, %45
  %47 = tail call double @sqrt(double %46) #30
  %48 = fadd double %46, %47
  %49 = tail call double @sqrt(double %48) #30
  %50 = fsub double %48, %49
  %51 = tail call double @sqrt(double %50) #30
  %52 = fsub double %50, %51
  %53 = tail call double @sqrt(double %52) #30
  %54 = fsub double %52, %53
  %55 = tail call double @sqrt(double %54) #30
  %56 = fsub double %54, %55
  %57 = tail call double @sqrt(double %56) #30
  %58 = fsub double %56, %57
  %59 = tail call double @sqrt(double %58) #30
  %60 = fsub double %58, %59
  %61 = tail call double @sqrt(double %60) #30
  %62 = fsub double %60, %61
  %63 = tail call double @sqrt(double %62) #30
  %64 = fsub double %62, %63
  %65 = tail call double @sqrt(double %64) #30
  %66 = fsub double %64, %65
  %67 = fptosi double %66 to i32
  %68 = load i32, i32* %16, align 4
  %69 = add nsw i32 %68, %67
  store i32 %69, i32* %16, align 4
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %19

LoopScheduler: Prologue

19:                                               ; preds = %22, %9
  %20 = phi i32 [ %69, %22 ], [ 0, %9 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %22 ], [ 0, %9 ]
  %21 = icmp slt i64 %indvars.iv, %12
  br i1 %21, label %22, label %70, !prof !31

LoopScheduler: Body

22:                                               ; preds = %19
  %23 = tail call double @sqrt(double %18) #30
  %24 = fadd double %23, %18
  %25 = tail call double @sqrt(double %24) #30
  %26 = fadd double %24, %25
  %27 = tail call double @sqrt(double %26) #30
  %28 = fadd double %26, %27
  %29 = tail call double @sqrt(double %28) #30
  %30 = fadd double %28, %29
  %31 = tail call double @sqrt(double %30) #30
  %32 = fadd double %30, %31
  %33 = tail call double @sqrt(double %32) #30
  %34 = fadd double %32, %33
  %35 = tail call double @sqrt(double %34) #30
  %36 = fadd double %34, %35
  %37 = tail call double @sqrt(double %36) #30
  %38 = fadd double %36, %37
  %39 = tail call double @sqrt(double %38) #30
  %40 = fadd double %38, %39
  %41 = tail call double @sqrt(double %40) #30
  %42 = fadd double %40, %41
  %43 = tail call double @sqrt(double %42) #30
  %44 = fadd double %42, %43
  %45 = tail call double @sqrt(double %44) #30
  %46 = fadd double %44, %45
  %47 = tail call double @sqrt(double %46) #30
  %48 = fadd double %46, %47
  %49 = tail call double @sqrt(double %48) #30
  %50 = fsub double %48, %49
  %51 = tail call double @sqrt(double %50) #30
  %52 = fsub double %50, %51
  %53 = tail call double @sqrt(double %52) #30
  %54 = fsub double %52, %53
  %55 = tail call double @sqrt(double %54) #30
  %56 = fsub double %54, %55
  %57 = tail call double @sqrt(double %56) #30
  %58 = fsub double %56, %57
  %59 = tail call double @sqrt(double %58) #30
  %60 = fsub double %58, %59
  %61 = tail call double @sqrt(double %60) #30
  %62 = fsub double %60, %61
  %63 = tail call double @sqrt(double %62) #30
  %64 = fsub double %62, %63
  %65 = tail call double @sqrt(double %64) #30
  %66 = fsub double %64, %65
  %67 = fptosi double %66 to i32
  %68 = load i32, i32* %16, align 4
  %69 = add nsw i32 %68, %67
  store i32 %69, i32* %16, align 4
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %19

LoopScheduler: Parent Function

; Function Attrs: inlinehint noinline norecurse uwtable
define dso_local i32 @main(i32, i8**) local_unnamed_addr #0 !prof !29 {
  %3 = icmp slt i32 %0, 2
  br i1 %3, label %4, label %9, !prof !30

4:                                                ; preds = %2
  %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  %6 = load i8*, i8** %1, align 8
  %7 = getelementptr [22 x i8], [22 x i8]* @.str, i64 0, i64 0
  %8 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %5, i8* %7, i8* %6) #28
  br label %73

9:                                                ; preds = %2
  %10 = getelementptr inbounds i8*, i8** %1, i64 1
  %11 = load i8*, i8** %10, align 8
  %12 = tail call i64 @atoll(i8* %11) #29
  %13 = getelementptr [25 x i8], [25 x i8]* @.str.1, i64 0, i64 0
  %14 = tail call i32 (i8*, ...) @printf(i8* %13, i64 %12)
  %15 = tail call noalias i8* @malloc(i64 4) #30
  %16 = bitcast i8* %15 to i32*
  store i32 0, i32* %16, align 4
  %17 = tail call i32 @rand() #30
  %18 = sitofp i32 %17 to double
  br label %19

19:                                               ; preds = %22, %9
  %20 = phi i32 [ %69, %22 ], [ 0, %9 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %22 ], [ 0, %9 ]
  %21 = icmp slt i64 %indvars.iv, %12
  br i1 %21, label %22, label %70, !prof !31

22:                                               ; preds = %19
  %23 = tail call double @sqrt(double %18) #30
  %24 = fadd double %23, %18
  %25 = tail call double @sqrt(double %24) #30
  %26 = fadd double %24, %25
  %27 = tail call double @sqrt(double %26) #30
  %28 = fadd double %26, %27
  %29 = tail call double @sqrt(double %28) #30
  %30 = fadd double %28, %29
  %31 = tail call double @sqrt(double %30) #30
  %32 = fadd double %30, %31
  %33 = tail call double @sqrt(double %32) #30
  %34 = fadd double %32, %33
  %35 = tail call double @sqrt(double %34) #30
  %36 = fadd double %34, %35
  %37 = tail call double @sqrt(double %36) #30
  %38 = fadd double %36, %37
  %39 = tail call double @sqrt(double %38) #30
  %40 = fadd double %38, %39
  %41 = tail call double @sqrt(double %40) #30
  %42 = fadd double %40, %41
  %43 = tail call double @sqrt(double %42) #30
  %44 = fadd double %42, %43
  %45 = tail call double @sqrt(double %44) #30
  %46 = fadd double %44, %45
  %47 = tail call double @sqrt(double %46) #30
  %48 = fadd double %46, %47
  %49 = tail call double @sqrt(double %48) #30
  %50 = fsub double %48, %49
  %51 = tail call double @sqrt(double %50) #30
  %52 = fsub double %50, %51
  %53 = tail call double @sqrt(double %52) #30
  %54 = fsub double %52, %53
  %55 = tail call double @sqrt(double %54) #30
  %56 = fsub double %54, %55
  %57 = tail call double @sqrt(double %56) #30
  %58 = fsub double %56, %57
  %59 = tail call double @sqrt(double %58) #30
  %60 = fsub double %58, %59
  %61 = tail call double @sqrt(double %60) #30
  %62 = fsub double %60, %61
  %63 = tail call double @sqrt(double %62) #30
  %64 = fsub double %62, %63
  %65 = tail call double @sqrt(double %64) #30
  %66 = fsub double %64, %65
  %67 = fptosi double %66 to i32
  %68 = load i32, i32* %16, align 4
  %69 = add nsw i32 %68, %67
  store i32 %69, i32* %16, align 4
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %19

70:                                               ; preds = %19
  %.lcssa = phi i32 [ %20, %19 ]
  %71 = getelementptr [13 x i8], [13 x i8]* @.str.2, i64 0, i64 0
  %72 = tail call i32 (i8*, ...) @printf(i8* %71, i32 %.lcssa)
  tail call void @free(i8* %15) #30
  br label %73

73:                                               ; preds = %70, %4
  %.0 = phi i32 [ 1, %4 ], [ 0, %70 ]
  ret i32 %.0
}

LoopScheduler: End dump ...
LoopScheduler:   canMoveAnyInstOutOfLoop
LoopScheduler:     Yes! Loop can be scheduled
LoopScheduler:     Yes! Loop can be quickly handled
LoopScheduler:       Next: 
19:                                               ; preds = %22, %9
  %20 = phi i32 [ %69, %22 ], [ 0, %9 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %22 ], [ 0, %9 ]
  %21 = icmp slt i64 %indvars.iv, %12
  br i1 %21, label %22, label %70, !prof !31

Scheduler: canMoveAnyInstOutOfBasicBlock --- @Block: 
19:                                               ; preds = %22, %9
  %20 = phi i32 [ %69, %22 ], [ 0, %9 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %22 ], [ 0, %9 ]
  %21 = icmp slt i64 %indvars.iv, %12
  br i1 %21, label %22, label %70, !prof !31

Scheduler:     Yes!
Scheduler:     Success for canMoveAnyInstOutOfBasicBlock...
Scheduler: getAllInstsMoveableOutOfBasicBlock --- @Block: 
19:                                               ; preds = %22, %9
  %20 = phi i32 [ %69, %22 ], [ 0, %9 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %22 ], [ 0, %9 ]
  %21 = icmp slt i64 %indvars.iv, %12
  br i1 %21, label %22, label %70, !prof !31

Scheduler:     Checking the block ...
Scheduler: canMoveAnyInstOutOfBasicBlock --- @Block: 
19:                                               ; preds = %22, %9
  %20 = phi i32 [ %69, %22 ], [ 0, %9 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %22 ], [ 0, %9 ]
  %21 = icmp slt i64 %indvars.iv, %12
  br i1 %21, label %22, label %70, !prof !31

Scheduler:     Yes!
Scheduler:     Success for canMoveAnyInstOutOfBasicBlock...
Scheduler:     Now the worklist...
Scheduler:       Next:   br i1 %21, label %22, label %70, !prof !31
Scheduler: canMoveInstOutOfBasicBlock --- @I:   br i1 %21, label %22, label %70, !prof !31
Scheduler:     No! @I is a PHI or terminator
Scheduler:         Keep --- Can't move Next!
Scheduler:       Next:   %21 = icmp slt i64 %indvars.iv, %12
Scheduler: canMoveInstOutOfBasicBlock --- @I:   %21 = icmp slt i64 %indvars.iv, %12
Scheduler:     Yes!
Scheduler:     Success for canMoveInstOutOfBasicBlock...
Scheduler:       Now the dependences...
         D:   br i1 %21, label %22, label %70, !prof !31
Scheduler: canMoveInstOutOfBasicBlock --- @I:   br i1 %21, label %22, label %70, !prof !31
Scheduler:     No! @I is a PHI or terminator
Scheduler:       Keep --- Dependence(s) can't be moved!
Scheduler:       Next:   %indvars.iv = phi i64 [ %indvars.iv.next, %22 ], [ 0, %9 ]
Scheduler: canMoveInstOutOfBasicBlock --- @I:   %indvars.iv = phi i64 [ %indvars.iv.next, %22 ], [ 0, %9 ]
Scheduler:     No! @I is a PHI or terminator
Scheduler:         Keep --- Can't move Next!
Scheduler:       Next:   %20 = phi i32 [ %69, %22 ], [ 0, %9 ]
Scheduler: canMoveInstOutOfBasicBlock --- @I:   %20 = phi i32 [ %69, %22 ], [ 0, %9 ]
Scheduler:     No! @I is a PHI or terminator
Scheduler:         Keep --- Can't move Next!
Scheduler: getAllInstsMoveableOutOfBasicBlock --- All moves (0): 
EnablersManager:   Try to extract invariants out of loops
EnablersManager:     Loop invariants have been extracted
EnablersManager: Exit
NOELLE: Enablers:       Normalize the code
noelle-norm /tmp/tmp.k2ny3UYWif -o /tmp/tmp.k2ny3UYWif
opt -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libCudd.so -basicaa -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars /tmp/tmp.k2ny3UYWif -o /tmp/tmp.k2ny3UYWif
NOELLE: Enablers:     Invocation 1
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Enablers.so -enablers /tmp/tmp.gGCrk64ZdJ -o /tmp/tmp.k2ny3UYWif -noelle-pdg-verbose=1 -noelle-verbose=2 -noelle-min-hot=0
opt -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Loops.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Noelle.so -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Enablers.so -enablers /tmp/tmp.gGCrk64ZdJ -o /tmp/tmp.k2ny3UYWif -noelle-pdg-verbose=1 -noelle-verbose=2 -noelle-min-hot=0
EnablersManager: Start
Parallelizer: Filter out cold code
EnablersManager:  Try to improve all 1 loops, one at a time
EnablersManager:   Try to apply loop distribution
EnablersManager:   Try to devirtualize indirect calls
EnablersManager:   Try to whilify loops
LoopWhilifier: Starting ... 
THE SCHEDULER
LoopScheduler: Starting dump ...
LoopScheduler: Blocks

64:                                               ; preds = %67, %9
  %65 = phi i32 [ %69, %67 ], [ 0, %9 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %67 ], [ 0, %9 ]
  %66 = icmp slt i64 %indvars.iv, %12
  br i1 %66, label %67, label %70, !prof !31


67:                                               ; preds = %64
  %68 = load i32, i32* %16, align 4
  %69 = add nsw i32 %68, %63
  store i32 %69, i32* %16, align 4
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %64

LoopScheduler: Latch

67:                                               ; preds = %64
  %68 = load i32, i32* %16, align 4
  %69 = add nsw i32 %68, %63
  store i32 %69, i32* %16, align 4
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %64

LoopScheduler: Prologue

64:                                               ; preds = %67, %9
  %65 = phi i32 [ %69, %67 ], [ 0, %9 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %67 ], [ 0, %9 ]
  %66 = icmp slt i64 %indvars.iv, %12
  br i1 %66, label %67, label %70, !prof !31

LoopScheduler: Body

67:                                               ; preds = %64
  %68 = load i32, i32* %16, align 4
  %69 = add nsw i32 %68, %63
  store i32 %69, i32* %16, align 4
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %64

LoopScheduler: Parent Function

; Function Attrs: inlinehint noinline norecurse uwtable
define dso_local i32 @main(i32, i8**) local_unnamed_addr #0 !prof !29 {
  %3 = icmp slt i32 %0, 2
  br i1 %3, label %4, label %9, !prof !30

4:                                                ; preds = %2
  %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  %6 = load i8*, i8** %1, align 8
  %7 = getelementptr [22 x i8], [22 x i8]* @.str, i64 0, i64 0
  %8 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %5, i8* %7, i8* %6) #28
  br label %73

9:                                                ; preds = %2
  %10 = getelementptr inbounds i8*, i8** %1, i64 1
  %11 = load i8*, i8** %10, align 8
  %12 = tail call i64 @atoll(i8* %11) #29
  %13 = getelementptr [25 x i8], [25 x i8]* @.str.1, i64 0, i64 0
  %14 = tail call i32 (i8*, ...) @printf(i8* %13, i64 %12)
  %15 = tail call noalias i8* @malloc(i64 4) #30
  %16 = bitcast i8* %15 to i32*
  store i32 0, i32* %16, align 4
  %17 = tail call i32 @rand() #30
  %18 = sitofp i32 %17 to double
  %19 = tail call double @sqrt(double %18) #30
  %20 = fadd double %19, %18
  %21 = tail call double @sqrt(double %20) #30
  %22 = fadd double %20, %21
  %23 = tail call double @sqrt(double %22) #30
  %24 = fadd double %22, %23
  %25 = tail call double @sqrt(double %24) #30
  %26 = fadd double %24, %25
  %27 = tail call double @sqrt(double %26) #30
  %28 = fadd double %26, %27
  %29 = tail call double @sqrt(double %28) #30
  %30 = fadd double %28, %29
  %31 = tail call double @sqrt(double %30) #30
  %32 = fadd double %30, %31
  %33 = tail call double @sqrt(double %32) #30
  %34 = fadd double %32, %33
  %35 = tail call double @sqrt(double %34) #30
  %36 = fadd double %34, %35
  %37 = tail call double @sqrt(double %36) #30
  %38 = fadd double %36, %37
  %39 = tail call double @sqrt(double %38) #30
  %40 = fadd double %38, %39
  %41 = tail call double @sqrt(double %40) #30
  %42 = fadd double %40, %41
  %43 = tail call double @sqrt(double %42) #30
  %44 = fadd double %42, %43
  %45 = tail call double @sqrt(double %44) #30
  %46 = fsub double %44, %45
  %47 = tail call double @sqrt(double %46) #30
  %48 = fsub double %46, %47
  %49 = tail call double @sqrt(double %48) #30
  %50 = fsub double %48, %49
  %51 = tail call double @sqrt(double %50) #30
  %52 = fsub double %50, %51
  %53 = tail call double @sqrt(double %52) #30
  %54 = fsub double %52, %53
  %55 = tail call double @sqrt(double %54) #30
  %56 = fsub double %54, %55
  %57 = tail call double @sqrt(double %56) #30
  %58 = fsub double %56, %57
  %59 = tail call double @sqrt(double %58) #30
  %60 = fsub double %58, %59
  %61 = tail call double @sqrt(double %60) #30
  %62 = fsub double %60, %61
  %63 = fptosi double %62 to i32
  br label %64

64:                                               ; preds = %67, %9
  %65 = phi i32 [ %69, %67 ], [ 0, %9 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %67 ], [ 0, %9 ]
  %66 = icmp slt i64 %indvars.iv, %12
  br i1 %66, label %67, label %70, !prof !31

67:                                               ; preds = %64
  %68 = load i32, i32* %16, align 4
  %69 = add nsw i32 %68, %63
  store i32 %69, i32* %16, align 4
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %64

70:                                               ; preds = %64
  %.lcssa = phi i32 [ %65, %64 ]
  %71 = getelementptr [13 x i8], [13 x i8]* @.str.2, i64 0, i64 0
  %72 = tail call i32 (i8*, ...) @printf(i8* %71, i32 %.lcssa)
  tail call void @free(i8* %15) #30
  br label %73

73:                                               ; preds = %70, %4
  %.0 = phi i32 [ 1, %4 ], [ 0, %70 ]
  ret i32 %.0
}

LoopScheduler: End dump ...
LoopScheduler:   canMoveAnyInstOutOfLoop
LoopScheduler:     Yes! Loop can be scheduled
LoopScheduler:     Yes! Loop can be quickly handled
LoopScheduler:       Next: 
64:                                               ; preds = %67, %9
  %65 = phi i32 [ %69, %67 ], [ 0, %9 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %67 ], [ 0, %9 ]
  %66 = icmp slt i64 %indvars.iv, %12
  br i1 %66, label %67, label %70, !prof !31

Scheduler: canMoveAnyInstOutOfBasicBlock --- @Block: 
64:                                               ; preds = %67, %9
  %65 = phi i32 [ %69, %67 ], [ 0, %9 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %67 ], [ 0, %9 ]
  %66 = icmp slt i64 %indvars.iv, %12
  br i1 %66, label %67, label %70, !prof !31

Scheduler:     Yes!
Scheduler:     Success for canMoveAnyInstOutOfBasicBlock...
Scheduler: getAllInstsMoveableOutOfBasicBlock --- @Block: 
64:                                               ; preds = %67, %9
  %65 = phi i32 [ %69, %67 ], [ 0, %9 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %67 ], [ 0, %9 ]
  %66 = icmp slt i64 %indvars.iv, %12
  br i1 %66, label %67, label %70, !prof !31

Scheduler:     Checking the block ...
Scheduler: canMoveAnyInstOutOfBasicBlock --- @Block: 
64:                                               ; preds = %67, %9
  %65 = phi i32 [ %69, %67 ], [ 0, %9 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %67 ], [ 0, %9 ]
  %66 = icmp slt i64 %indvars.iv, %12
  br i1 %66, label %67, label %70, !prof !31

Scheduler:     Yes!
Scheduler:     Success for canMoveAnyInstOutOfBasicBlock...
Scheduler:     Now the worklist...
Scheduler:       Next:   br i1 %66, label %67, label %70, !prof !31
Scheduler: canMoveInstOutOfBasicBlock --- @I:   br i1 %66, label %67, label %70, !prof !31
Scheduler:     No! @I is a PHI or terminator
Scheduler:         Keep --- Can't move Next!
Scheduler:       Next:   %66 = icmp slt i64 %indvars.iv, %12
Scheduler: canMoveInstOutOfBasicBlock --- @I:   %66 = icmp slt i64 %indvars.iv, %12
Scheduler:     Yes!
Scheduler:     Success for canMoveInstOutOfBasicBlock...
Scheduler:       Now the dependences...
         D:   br i1 %66, label %67, label %70, !prof !31
Scheduler: canMoveInstOutOfBasicBlock --- @I:   br i1 %66, label %67, label %70, !prof !31
Scheduler:     No! @I is a PHI or terminator
Scheduler:       Keep --- Dependence(s) can't be moved!
Scheduler:       Next:   %indvars.iv = phi i64 [ %indvars.iv.next, %67 ], [ 0, %9 ]
Scheduler: canMoveInstOutOfBasicBlock --- @I:   %indvars.iv = phi i64 [ %indvars.iv.next, %67 ], [ 0, %9 ]
Scheduler:     No! @I is a PHI or terminator
Scheduler:         Keep --- Can't move Next!
Scheduler:       Next:   %65 = phi i32 [ %69, %67 ], [ 0, %9 ]
Scheduler: canMoveInstOutOfBasicBlock --- @I:   %65 = phi i32 [ %69, %67 ], [ 0, %9 ]
Scheduler:     No! @I is a PHI or terminator
Scheduler:         Keep --- Can't move Next!
Scheduler: getAllInstsMoveableOutOfBasicBlock --- All moves (0): 
EnablersManager:   Try to extract invariants out of loops
Mem2Reg: Checking loop:   br i1 %66, label %67, label %70, !prof !31
Mem2Reg:  Possible loop invariant memory location:   %16 = bitcast i8* %15 to i32*
Mem2Reg:  Loop invariant memory location:   %16 = bitcast i8* %15 to i32*
Mem2Reg:  SCC:
Internal nodes: 3
	  %68 = load i32, i32* %16, align 4
	  store i32 %69, i32* %16, align 4
	  %69 = add nsw i32 %68, %63
External nodes: 2
	  br i1 %66, label %67, label %70, !prof !31
	  %65 = phi i32 [ %69, %67 ], [ 0, %9 ]
Edges: 8

Mem2Reg:  Collecting and ordering memory loads/stores by basic block
Mem2Reg: Iterating basic blocks to determine last stored values
Mem2Reg: placeholder PHI required: label %65
Mem2Reg:  checking for last value entering block: label %65
Mem2Reg:  Last value entering block: label %65	  %67 = phi i32 
Mem2Reg:  checking for last value entering block: label %69
Mem2Reg:  Last value entering block: label %69	  %67 = phi i32 
Mem2Reg:  Value updated:   %71 = add nsw i32 %67, %63
Mem2Reg:  Removing
  %70 = load i32, i32* %16, align 4
Mem2Reg:  Removing
  store i32 %70, i32* %16, align 4
Mem2Reg:  Loop invariant memory location loads/stores promoted: 1   %16 = bitcast i8* %15 to i32*
EnablersManager:     Loop invariants have been extracted
EnablersManager: Exit
NOELLE: Enablers:       Normalize the code
noelle-norm /tmp/tmp.k2ny3UYWif -o /tmp/tmp.k2ny3UYWif
opt -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libCudd.so -basicaa -mem2reg -simplifycfg-sink-common=false -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa -indvars /tmp/tmp.k2ny3UYWif -o /tmp/tmp.k2ny3UYWif
NOELLE: Enablers:     Invocation 2
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Enablers.so -enablers /tmp/tmp.gGCrk64ZdJ -o /tmp/tmp.k2ny3UYWif -noelle-pdg-verbose=1 -noelle-verbose=2 -noelle-min-hot=0
opt -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Loops.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Noelle.so -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopDistribution.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopUnroll.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopWhilify.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopInvariantCodeMotion.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/SCEVSimplification.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Enablers.so -enablers /tmp/tmp.gGCrk64ZdJ -o /tmp/tmp.k2ny3UYWif -noelle-pdg-verbose=1 -noelle-verbose=2 -noelle-min-hot=0
EnablersManager: Start
Parallelizer: Filter out cold code
EnablersManager:  Try to improve all 1 loops, one at a time
EnablersManager:   Try to apply loop distribution
EnablersManager:   Try to devirtualize indirect calls
EnablersManager:   Try to whilify loops
LoopWhilifier: Starting ... 
THE SCHEDULER
LoopScheduler: Starting dump ...
LoopScheduler: Blocks

65:                                               ; preds = %69, %9
  %66 = phi i32 [ %70, %69 ], [ 0, %9 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %69 ], [ 0, %9 ]
  %67 = phi i32 [ %70, %69 ], [ %64, %9 ]
  %68 = icmp slt i64 %indvars.iv, %12
  br i1 %68, label %69, label %71, !prof !31


69:                                               ; preds = %65
  %70 = add nsw i32 %67, %63
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %65

LoopScheduler: Latch

69:                                               ; preds = %65
  %70 = add nsw i32 %67, %63
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %65

LoopScheduler: Prologue

65:                                               ; preds = %69, %9
  %66 = phi i32 [ %70, %69 ], [ 0, %9 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %69 ], [ 0, %9 ]
  %67 = phi i32 [ %70, %69 ], [ %64, %9 ]
  %68 = icmp slt i64 %indvars.iv, %12
  br i1 %68, label %69, label %71, !prof !31

LoopScheduler: Body

69:                                               ; preds = %65
  %70 = add nsw i32 %67, %63
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %65

LoopScheduler: Parent Function

; Function Attrs: inlinehint noinline norecurse uwtable
define dso_local i32 @main(i32, i8**) local_unnamed_addr #0 !prof !29 {
  %3 = icmp slt i32 %0, 2
  br i1 %3, label %4, label %9, !prof !30

4:                                                ; preds = %2
  %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  %6 = load i8*, i8** %1, align 8
  %7 = getelementptr [22 x i8], [22 x i8]* @.str, i64 0, i64 0
  %8 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %5, i8* %7, i8* %6) #28
  br label %74

9:                                                ; preds = %2
  %10 = getelementptr inbounds i8*, i8** %1, i64 1
  %11 = load i8*, i8** %10, align 8
  %12 = tail call i64 @atoll(i8* %11) #29
  %13 = getelementptr [25 x i8], [25 x i8]* @.str.1, i64 0, i64 0
  %14 = tail call i32 (i8*, ...) @printf(i8* %13, i64 %12)
  %15 = tail call noalias i8* @malloc(i64 4) #30
  %16 = bitcast i8* %15 to i32*
  store i32 0, i32* %16, align 4
  %17 = tail call i32 @rand() #30
  %18 = sitofp i32 %17 to double
  %19 = tail call double @sqrt(double %18) #30
  %20 = fadd double %19, %18
  %21 = tail call double @sqrt(double %20) #30
  %22 = fadd double %20, %21
  %23 = tail call double @sqrt(double %22) #30
  %24 = fadd double %22, %23
  %25 = tail call double @sqrt(double %24) #30
  %26 = fadd double %24, %25
  %27 = tail call double @sqrt(double %26) #30
  %28 = fadd double %26, %27
  %29 = tail call double @sqrt(double %28) #30
  %30 = fadd double %28, %29
  %31 = tail call double @sqrt(double %30) #30
  %32 = fadd double %30, %31
  %33 = tail call double @sqrt(double %32) #30
  %34 = fadd double %32, %33
  %35 = tail call double @sqrt(double %34) #30
  %36 = fadd double %34, %35
  %37 = tail call double @sqrt(double %36) #30
  %38 = fadd double %36, %37
  %39 = tail call double @sqrt(double %38) #30
  %40 = fadd double %38, %39
  %41 = tail call double @sqrt(double %40) #30
  %42 = fadd double %40, %41
  %43 = tail call double @sqrt(double %42) #30
  %44 = fadd double %42, %43
  %45 = tail call double @sqrt(double %44) #30
  %46 = fsub double %44, %45
  %47 = tail call double @sqrt(double %46) #30
  %48 = fsub double %46, %47
  %49 = tail call double @sqrt(double %48) #30
  %50 = fsub double %48, %49
  %51 = tail call double @sqrt(double %50) #30
  %52 = fsub double %50, %51
  %53 = tail call double @sqrt(double %52) #30
  %54 = fsub double %52, %53
  %55 = tail call double @sqrt(double %54) #30
  %56 = fsub double %54, %55
  %57 = tail call double @sqrt(double %56) #30
  %58 = fsub double %56, %57
  %59 = tail call double @sqrt(double %58) #30
  %60 = fsub double %58, %59
  %61 = tail call double @sqrt(double %60) #30
  %62 = fsub double %60, %61
  %63 = fptosi double %62 to i32
  %64 = load i32, i32* %16
  br label %65

65:                                               ; preds = %69, %9
  %66 = phi i32 [ %70, %69 ], [ 0, %9 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %69 ], [ 0, %9 ]
  %67 = phi i32 [ %70, %69 ], [ %64, %9 ]
  %68 = icmp slt i64 %indvars.iv, %12
  br i1 %68, label %69, label %71, !prof !31

69:                                               ; preds = %65
  %70 = add nsw i32 %67, %63
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %65

71:                                               ; preds = %65
  %.lcssa1 = phi i32 [ %67, %65 ]
  %.lcssa = phi i32 [ %66, %65 ]
  store i32 %.lcssa1, i32* %16
  %72 = getelementptr [13 x i8], [13 x i8]* @.str.2, i64 0, i64 0
  %73 = tail call i32 (i8*, ...) @printf(i8* %72, i32 %.lcssa)
  tail call void @free(i8* %15) #30
  br label %74

74:                                               ; preds = %71, %4
  %.0 = phi i32 [ 1, %4 ], [ 0, %71 ]
  ret i32 %.0
}

LoopScheduler: End dump ...
LoopScheduler:   canMoveAnyInstOutOfLoop
LoopScheduler:     Yes! Loop can be scheduled
LoopScheduler:     Yes! Loop can be quickly handled
LoopScheduler:       Next: 
65:                                               ; preds = %69, %9
  %66 = phi i32 [ %70, %69 ], [ 0, %9 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %69 ], [ 0, %9 ]
  %67 = phi i32 [ %70, %69 ], [ %64, %9 ]
  %68 = icmp slt i64 %indvars.iv, %12
  br i1 %68, label %69, label %71, !prof !31

Scheduler: canMoveAnyInstOutOfBasicBlock --- @Block: 
65:                                               ; preds = %69, %9
  %66 = phi i32 [ %70, %69 ], [ 0, %9 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %69 ], [ 0, %9 ]
  %67 = phi i32 [ %70, %69 ], [ %64, %9 ]
  %68 = icmp slt i64 %indvars.iv, %12
  br i1 %68, label %69, label %71, !prof !31

Scheduler:     Yes!
Scheduler:     Success for canMoveAnyInstOutOfBasicBlock...
Scheduler: getAllInstsMoveableOutOfBasicBlock --- @Block: 
65:                                               ; preds = %69, %9
  %66 = phi i32 [ %70, %69 ], [ 0, %9 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %69 ], [ 0, %9 ]
  %67 = phi i32 [ %70, %69 ], [ %64, %9 ]
  %68 = icmp slt i64 %indvars.iv, %12
  br i1 %68, label %69, label %71, !prof !31

Scheduler:     Checking the block ...
Scheduler: canMoveAnyInstOutOfBasicBlock --- @Block: 
65:                                               ; preds = %69, %9
  %66 = phi i32 [ %70, %69 ], [ 0, %9 ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %69 ], [ 0, %9 ]
  %67 = phi i32 [ %70, %69 ], [ %64, %9 ]
  %68 = icmp slt i64 %indvars.iv, %12
  br i1 %68, label %69, label %71, !prof !31

Scheduler:     Yes!
Scheduler:     Success for canMoveAnyInstOutOfBasicBlock...
Scheduler:     Now the worklist...
Scheduler:       Next:   br i1 %68, label %69, label %71, !prof !31
Scheduler: canMoveInstOutOfBasicBlock --- @I:   br i1 %68, label %69, label %71, !prof !31
Scheduler:     No! @I is a PHI or terminator
Scheduler:         Keep --- Can't move Next!
Scheduler:       Next:   %68 = icmp slt i64 %indvars.iv, %12
Scheduler: canMoveInstOutOfBasicBlock --- @I:   %68 = icmp slt i64 %indvars.iv, %12
Scheduler:     Yes!
Scheduler:     Success for canMoveInstOutOfBasicBlock...
Scheduler:       Now the dependences...
         D:   br i1 %68, label %69, label %71, !prof !31
Scheduler: canMoveInstOutOfBasicBlock --- @I:   br i1 %68, label %69, label %71, !prof !31
Scheduler:     No! @I is a PHI or terminator
Scheduler:       Keep --- Dependence(s) can't be moved!
Scheduler:       Next:   %67 = phi i32 [ %70, %69 ], [ %64, %9 ]
Scheduler: canMoveInstOutOfBasicBlock --- @I:   %67 = phi i32 [ %70, %69 ], [ %64, %9 ]
Scheduler:     No! @I is a PHI or terminator
Scheduler:         Keep --- Can't move Next!
Scheduler:       Next:   %indvars.iv = phi i64 [ %indvars.iv.next, %69 ], [ 0, %9 ]
Scheduler: canMoveInstOutOfBasicBlock --- @I:   %indvars.iv = phi i64 [ %indvars.iv.next, %69 ], [ 0, %9 ]
Scheduler:     No! @I is a PHI or terminator
Scheduler:         Keep --- Can't move Next!
Scheduler:       Next:   %66 = phi i32 [ %70, %69 ], [ 0, %9 ]
Scheduler: canMoveInstOutOfBasicBlock --- @I:   %66 = phi i32 [ %70, %69 ], [ 0, %9 ]
Scheduler:     No! @I is a PHI or terminator
Scheduler:         Keep --- Can't move Next!
Scheduler: getAllInstsMoveableOutOfBasicBlock --- All moves (0): 
EnablersManager:   Try to extract invariants out of loops
Mem2Reg: Checking loop:   br i1 %68, label %69, label %71, !prof !31
EnablersManager:   Try to simplify IV related SCEVs and their corresponding instructions in loops
SCEVSimplification:  Start
EnablersManager:   Try to simplify constant SCEVs and their corresponding instructions in loops
EnablersManager: Exit
NOELLE: Enablers: Exit
noelle-simplification baseline_pre.bc -o baseline_pre.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libCudd.so -basicaa -mem2reg -simplifycfg -simplifycfg-sink-common=false -instcombine -tailcallelim -loop-simplify -lcssa -licm -loop-unswitch -globalopt -instcombine -ipsccp -dce -gvn -dse -adce -loop-simplify -lcssa -indvars -loop-deletion -instcombine -indvars -break-constgeps -lowerswitch -mergereturn --break-crit-edges -loop-simplify -lcssa baseline_pre.bc -o baseline_pre.bc
noelle-meta-loop-embed baseline_pre.bc -o baseline_pre.bc
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopMetadata.so -LoopMetadata baseline_pre.bc -o baseline_pre.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Loops.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Noelle.so -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopMetadata.so -LoopMetadata baseline_pre.bc -o baseline_pre.bc
noelle-meta-clean baseline_pre.bc baseline_pre.bc
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CleanMetadata.so -CleanMetadata -clean-prof-metadata=true -clean-pdg-metadata=true baseline_pre.bc -o baseline_pre.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Loops.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Noelle.so -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CleanMetadata.so -CleanMetadata -clean-prof-metadata=true -clean-pdg-metadata=true baseline_pre.bc -o baseline_pre.bc
Clean PDG Metadata
Clean profiler metadata
opt --strip-named-metadata baseline_pre.bc -o baseline_pre.bc
llvm-dis baseline_pre.bc
clang++ -std=c++14 -pthreads -O3 baseline_pre.bc -lm -lstdc++ -lpthread -o testseq
noelle-prof-coverage baseline_pre.bc baseline_pre_prof -lm -lstdc++ -lpthread
./baseline_pre_prof `cat input.txt` 
Running 20 iterations
Result = 1729447412
noelle-meta-prof-embed default.profraw baseline_pre.bc -o baseline_with_metadata.bc
opt -pgo-test-profile-file=/tmp/tmp.gZB8VC0niK -block-freq -pgo-instr-use baseline_pre.bc -o baseline_with_metadata.bc
noelle-meta-pdg-embed baseline_with_metadata.bc -o baseline_with_metadata.bc
noelle-load -PDGAnalysis -noelle-pdg-verbose=3 -noelle-pdg-embed baseline_with_metadata.bc -o baseline_with_metadata.bc
opt -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Loops.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Noelle.so -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -PDGAnalysis -noelle-pdg-verbose=3 -noelle-pdg-embed baseline_with_metadata.bc -o baseline_with_metadata.bc
PDGAnalysis: Construct PDG from Analysis
Embed PDG as Metadata
llvm-dis baseline_with_metadata.bc
noelle-parallelizer baseline_with_metadata.bc -o test_parallelized_unoptimized.bc -noelle-pdg-verbose=1 -noelle-verbose=2 -noelle-min-hot=0 -alloc-aa-verbose=1 -noelle-parallelizer-force
noelle-parallel-load -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Parallelizer.so -parallelizer baseline_with_metadata.bc -o test_parallelized_unoptimized.bc -noelle-pdg-verbose=1 -noelle-verbose=2 -noelle-min-hot=0 -alloc-aa-verbose=1 -noelle-parallelizer-force
noelle-load -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Parallelizer.so -parallelizer baseline_with_metadata.bc -o test_parallelized_unoptimized.bc -noelle-pdg-verbose=1 -noelle-verbose=2 -noelle-min-hot=0 -alloc-aa-verbose=1 -noelle-parallelizer-force
opt -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSvf.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libCudd.so -stat=false -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libSCAFUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/libMemoryAnalysisModules.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/AllocAA.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/TalkDown.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/CallGraph.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/PDGAnalysis.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Architecture.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/BasicUtilities.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Task.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DataFlow.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/HotProfiler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/LoopStructure.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Loops.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Scheduler.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/OutlinerPass.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Noelle.so -globals-aa -cfl-steens-aa -tbaa -scev-aa -cfl-anders-aa -basic-loop-aa -scev-loop-aa -auto-restrict-aa -intrinsic-aa -global-malloc-aa -pure-fun-aa -semi-local-fun-aa -phi-maze-aa -no-capture-global-aa -no-capture-src-aa -type-aa -no-escape-fields-aa -acyclic-aa -disjoint-fields-aa -field-malloc-aa -loop-variant-allocation-aa -std-in-out-err-aa -array-of-structures-aa -kill-flow-aa -callsite-depth-combinator-aa -unique-access-paths-aa -llvm-aa-results -scalar-evolution -loops -domtree -postdomtree -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Heuristics.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/ParallelizationTechnique.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DSWP.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/DOALL.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/HELIX.so -load /nfs-scratch/simonec/parallelism/parallelization/NOELLE/install/lib/Parallelizer.so -parallelizer baseline_with_metadata.bc -o test_parallelized_unoptimized.bc -noelle-pdg-verbose=1 -noelle-verbose=2 -noelle-min-hot=0 -alloc-aa-verbose=1 -noelle-parallelizer-force
AllocAA at "runOnModule"
AllocAA:  GV value is a primitive integer array: 0, @.str = private unnamed_addr constant [22 x i8] c"USAGE: %s ITERATIONS\0A\00", align 1
AllocAA:  GV value is a primitive integer array: 0, @.str.1 = private unnamed_addr constant [25 x i8] c"Running %lld iterations\0A\00", align 1
AllocAA:  GV value is a primitive integer array: 0, @.str.2 = private unnamed_addr constant [13 x i8] c"Result = %d\0A\00", align 1
Parallelizer: Analyzing the module baseline_with_metadata.bc
Parallelizer: Filter out cold code
Parallelizer:  There are 0 loops in the program we are going to consider
Parallelizer:  Filter out loops not worth considering
Parallelizer:  There are 0 loop nesting trees in the program
llvm-dis test_parallelized_unoptimized.bc
clang++ -O3 -c -emit-llvm test_parallelized_unoptimized.bc -o test_parallelized.bc
llvm-dis test_parallelized.bc
clang++ -std=c++14 -pthreads -O3 test_parallelized.bc -lm -lstdc++ -lpthread -o parallelized
